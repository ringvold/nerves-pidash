-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module EnturApi.Query exposing (AuthorityRequiredArguments, BikeParkRequiredArguments, BikeRentalStationRequiredArguments, BikeRentalStationsByBboxOptionalArguments, BikeRentalStationsOptionalArguments, CarParkRequiredArguments, CarParksOptionalArguments, LineRequiredArguments, LinesOptionalArguments, NearestOptionalArguments, NearestRequiredArguments, OperatorRequiredArguments, OrganisationRequiredArguments, QuayRequiredArguments, QuaysByBboxOptionalArguments, QuaysByRadiusOptionalArguments, QuaysByRadiusRequiredArguments, QuaysOptionalArguments, ServiceJourneyRequiredArguments, ServiceJourneysOptionalArguments, SituationsOptionalArguments, StopPlaceRequiredArguments, StopPlacesByBboxOptionalArguments, StopPlacesOptionalArguments, TripOptionalArguments, TripRequiredArguments, authorities, authority, bikePark, bikeParks, bikeRentalStation, bikeRentalStations, bikeRentalStationsByBbox, carPark, carParks, line, lines, nearest, notices, operator, operators, organisation, organisations, quay, quays, quaysByBbox, quaysByRadius, routingParameters, serviceJourney, serviceJourneys, situations, stopPlace, stopPlaces, stopPlacesByBbox, trip)

import EnturApi.Enum.FilterPlaceType
import EnturApi.Enum.FlexibleLineType
import EnturApi.Enum.Locale
import EnturApi.Enum.Mode
import EnturApi.Enum.MultiModalMode
import EnturApi.Enum.OptimisationMethod
import EnturApi.Enum.Severity
import EnturApi.Enum.TransportMode
import EnturApi.InputObject
import EnturApi.Interface
import EnturApi.Object
import EnturApi.Scalar
import EnturApi.ScalarCodecs
import EnturApi.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias TripOptionalArguments =
    { dateTime : OptionalArgument EnturApi.ScalarCodecs.DateTime
    , wheelchair : OptionalArgument Bool
    , numTripPatterns : OptionalArgument Int
    , maximumWalkDistance : OptionalArgument Float
    , maxTransferWalkDistance : OptionalArgument Float
    , walkSpeed : OptionalArgument Float
    , bikeSpeed : OptionalArgument Float
    , optimisationMethod : OptionalArgument EnturApi.Enum.OptimisationMethod.OptimisationMethod
    , arriveBy : OptionalArgument Bool
    , vias : OptionalArgument (List (Maybe EnturApi.InputObject.Location))
    , preferred : OptionalArgument EnturApi.InputObject.InputPreferred
    , unpreferred : OptionalArgument EnturApi.InputObject.InputUnpreferred
    , banned : OptionalArgument EnturApi.InputObject.InputBanned
    , whiteListed : OptionalArgument EnturApi.InputObject.InputWhiteListed
    , transferPenalty : OptionalArgument Int
    , modes : OptionalArgument (List (Maybe EnturApi.Enum.Mode.Mode))
    , transportSubmodes : OptionalArgument (List (Maybe EnturApi.InputObject.TransportSubmodeFilter))
    , allowBikeRental : OptionalArgument Bool
    , minimumTransferTime : OptionalArgument Int
    , maximumTransfers : OptionalArgument Int
    , ignoreRealtimeUpdates : OptionalArgument Bool
    , includePlannedCancellations : OptionalArgument Bool
    , ignoreInterchanges : OptionalArgument Bool
    , locale : OptionalArgument EnturApi.Enum.Locale.Locale
    , heuristicStepsPerMainStep : OptionalArgument Int
    , compactLegsByReversedSearch : OptionalArgument Bool
    , reverseOptimizeOnTheFly : OptionalArgument Bool
    , maxPreTransitTime : OptionalArgument Int
    , preTransitPenalty : OptionalArgument Float
    , preTransitOverageRate : OptionalArgument Float
    , preTransitReluctance : OptionalArgument Float
    , maxPreTransitWalkDistance : OptionalArgument Float
    , useFlex : OptionalArgument Bool
    , banFirstServiceJourneysFromReuseNo : OptionalArgument Int
    , walkBoardCost : OptionalArgument Int
    , walkReluctance : OptionalArgument Float
    , waitReluctance : OptionalArgument Float
    , ignoreMinimumBookingPeriod : OptionalArgument Bool
    , transitDistanceReluctance : OptionalArgument Float
    }


type alias TripRequiredArguments =
    { from : EnturApi.InputObject.Location
    , to : EnturApi.InputObject.Location
    }


{-| Input type for executing a travel search for a trip between two locations. Returns trip patterns describing suggested alternatives for the trip.

  - dateTime - Date and time for the earliest time the user is willing to start the journey (if arriveBy=false/not set) or the latest acceptable time of arriving (arriveBy=true). Defaults to now
  - from - The start location
  - to - The end location
  - wheelchair - Whether the trip must be wheelchair accessible.
  - numTripPatterns - The maximum number of trip patterns to return.
  - maximumWalkDistance - DEPRECATED - Use maxPreTransitWalkDistance/maxTransferWalkDistance instead. The maximum distance (in meters) the user is willing to walk. Note that trip patterns with longer walking distances will be penalized, but not altogether disallowed. Maximum allowed value is 15000 m
  - maxTransferWalkDistance - The maximum walk distance allowed for transfers.
  - walkSpeed - The maximum walk speed along streets, in meters per second
  - bikeSpeed - The maximum bike speed along streets, in meters per second
  - optimisationMethod - The set of characteristics that the user wants to optimise for -- defaults to quick
  - arriveBy - Whether the trip should depart at dateTime (false, the default), or arrive at dateTime.
  - vias - An ordered list of intermediate locations to be visited.
  - preferred - Parameters for indicating authorities or lines that preferably should be used in trip patters. A cost is applied to boarding nonpreferred authorities or lines (otherThanPreferredRoutesPenalty).
  - unpreferred - Parameters for indicating authorities or lines that preferably should not be used in trip patters. A cost is applied to boarding nonpreferred authorities or lines (otherThanPreferredRoutesPenalty).
  - banned - Parameters for indicating authorities, lines or quays not be used in the trip patterns
  - whiteListed - Parameters for indicating the only authorities, lines or quays to be used in the trip patterns
  - transferPenalty - An extra penalty added on transfers (i.e. all boardings except the first one). The transferPenalty is used when a user requests even less transfers. In the latter case, we don't actually optimise for fewest transfers, as this can lead to absurd results. Consider a trip in New York from Grand Army Plaza (the one in Brooklyn) to Kalustyan's at noon. The true lowest transfers trip pattern is to wait until midnight, when the 4 train runs local the whole way. The actual fastest trip pattern is the 2/3 to the 4/5 at Nevins to the 6 at Union Square, which takes half an hour. Even someone optimise for fewest transfers doesn't want to wait until midnight. Maybe they would be willing to walk to 7th Ave and take the Q to Union Square, then transfer to the 6. If this takes less than transferPenalty seconds, then that's what we'll return.
  - modes - The set of modes that a user is willing to use. Defaults to [air, bus, cableway, water, funicular, lift, rail, metro, tram, coach, transit, foot]
  - transportSubmodes - Optional set of allowed submodes per transport mode provided in 'modes'. If at least one submode is set for a transport mode all submodes not set will be disregarded. Note that transportMode must also be included in 'modes' for the submodes to be allowed
  - allowBikeRental - Is bike rental allowed?
  - minimumTransferTime - A global minimum transfer time (in seconds) that specifies the minimum amount of time that must pass between exiting one public transport vehicle and boarding another. This time is in addition to time it might take to walk between stops.
  - maximumTransfers - Maximum number of transfers
  - ignoreRealtimeUpdates - When true, realtime updates are ignored during this search.
  - includePlannedCancellations - When true, service journeys cancelled in scheduled route data will be included during this search.
  - ignoreInterchanges - DEPRECATED - For debugging only. Ignores interchanges defined in timetable data.
  - heuristicStepsPerMainStep - Search algorithm tuning parameter.
  - compactLegsByReversedSearch - Whether legs should be compacted by performing a reversed search. Experimental argument, will be removed!.
  - reverseOptimizeOnTheFly - For debugging only.
  - maxPreTransitTime - Maximum time for the ride part of "kiss and ride" and "ride and kiss".
  - preTransitPenalty - A one time jump in cost for exceeding the maximum time of the ride part of "kiss and ride" and "ride and kiss".
  - preTransitOverageRate - A multiplier in cost when over the maximum time of the ride part of "kiss and ride" and "ride and kiss".
  - preTransitReluctance - How much worse driving before and after transit is than riding on transit. Applies to ride and kiss, kiss and ride and park and ride.
  - maxPreTransitWalkDistance - Max walk distance for access/egress legs.
  - banFirstServiceJourneysFromReuseNo - How many service journeys used in a tripPatterns should be banned from inclusion in successive tripPatterns. Counting from start of tripPattern.
  - walkBoardCost - DEPRECATED - ONLY FOR TESTING. Cost applied each time transit is boarded.
  - walkReluctance - Walk cost is multiplied by this value. This is the main parameter to use for limiting walking.
  - waitReluctance - DEPRECATED - ONLY FOR TESTING. Wait cost is multiplied by this value.
  - ignoreMinimumBookingPeriod - Ignore the MinimumBookingPeriod defined on the ServiceJourney and allow itineraries to start immediately after the current time.
  - transitDistanceReluctance - The extra cost per meter that is travelled by transit. This is a cost point peter meter, so it should in most
    cases be a very small fraction. The purpose of assigning a cost to distance is often because it correlates with
    fare prices and you want to avoid situations where you take detours or travel back again even if it is
    technically faster. Setting this value to 0 turns off the feature altogether.

-}
trip : (TripOptionalArguments -> TripOptionalArguments) -> TripRequiredArguments -> SelectionSet decodesTo EnturApi.Object.Trip -> SelectionSet (Maybe decodesTo) RootQuery
trip fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { dateTime = Absent, wheelchair = Absent, numTripPatterns = Absent, maximumWalkDistance = Absent, maxTransferWalkDistance = Absent, walkSpeed = Absent, bikeSpeed = Absent, optimisationMethod = Absent, arriveBy = Absent, vias = Absent, preferred = Absent, unpreferred = Absent, banned = Absent, whiteListed = Absent, transferPenalty = Absent, modes = Absent, transportSubmodes = Absent, allowBikeRental = Absent, minimumTransferTime = Absent, maximumTransfers = Absent, ignoreRealtimeUpdates = Absent, includePlannedCancellations = Absent, ignoreInterchanges = Absent, locale = Absent, heuristicStepsPerMainStep = Absent, compactLegsByReversedSearch = Absent, reverseOptimizeOnTheFly = Absent, maxPreTransitTime = Absent, preTransitPenalty = Absent, preTransitOverageRate = Absent, preTransitReluctance = Absent, maxPreTransitWalkDistance = Absent, useFlex = Absent, banFirstServiceJourneysFromReuseNo = Absent, walkBoardCost = Absent, walkReluctance = Absent, waitReluctance = Absent, ignoreMinimumBookingPeriod = Absent, transitDistanceReluctance = Absent }

        optionalArgs =
            [ Argument.optional "dateTime" filledInOptionals.dateTime (EnturApi.ScalarCodecs.codecs |> EnturApi.Scalar.unwrapEncoder .codecDateTime), Argument.optional "wheelchair" filledInOptionals.wheelchair Encode.bool, Argument.optional "numTripPatterns" filledInOptionals.numTripPatterns Encode.int, Argument.optional "maximumWalkDistance" filledInOptionals.maximumWalkDistance Encode.float, Argument.optional "maxTransferWalkDistance" filledInOptionals.maxTransferWalkDistance Encode.float, Argument.optional "walkSpeed" filledInOptionals.walkSpeed Encode.float, Argument.optional "bikeSpeed" filledInOptionals.bikeSpeed Encode.float, Argument.optional "optimisationMethod" filledInOptionals.optimisationMethod (Encode.enum EnturApi.Enum.OptimisationMethod.toString), Argument.optional "arriveBy" filledInOptionals.arriveBy Encode.bool, Argument.optional "vias" filledInOptionals.vias (EnturApi.InputObject.encodeLocation |> Encode.maybe |> Encode.list), Argument.optional "preferred" filledInOptionals.preferred EnturApi.InputObject.encodeInputPreferred, Argument.optional "unpreferred" filledInOptionals.unpreferred EnturApi.InputObject.encodeInputUnpreferred, Argument.optional "banned" filledInOptionals.banned EnturApi.InputObject.encodeInputBanned, Argument.optional "whiteListed" filledInOptionals.whiteListed EnturApi.InputObject.encodeInputWhiteListed, Argument.optional "transferPenalty" filledInOptionals.transferPenalty Encode.int, Argument.optional "modes" filledInOptionals.modes (Encode.enum EnturApi.Enum.Mode.toString |> Encode.maybe |> Encode.list), Argument.optional "transportSubmodes" filledInOptionals.transportSubmodes (EnturApi.InputObject.encodeTransportSubmodeFilter |> Encode.maybe |> Encode.list), Argument.optional "allowBikeRental" filledInOptionals.allowBikeRental Encode.bool, Argument.optional "minimumTransferTime" filledInOptionals.minimumTransferTime Encode.int, Argument.optional "maximumTransfers" filledInOptionals.maximumTransfers Encode.int, Argument.optional "ignoreRealtimeUpdates" filledInOptionals.ignoreRealtimeUpdates Encode.bool, Argument.optional "includePlannedCancellations" filledInOptionals.includePlannedCancellations Encode.bool, Argument.optional "ignoreInterchanges" filledInOptionals.ignoreInterchanges Encode.bool, Argument.optional "locale" filledInOptionals.locale (Encode.enum EnturApi.Enum.Locale.toString), Argument.optional "heuristicStepsPerMainStep" filledInOptionals.heuristicStepsPerMainStep Encode.int, Argument.optional "compactLegsByReversedSearch" filledInOptionals.compactLegsByReversedSearch Encode.bool, Argument.optional "reverseOptimizeOnTheFly" filledInOptionals.reverseOptimizeOnTheFly Encode.bool, Argument.optional "maxPreTransitTime" filledInOptionals.maxPreTransitTime Encode.int, Argument.optional "preTransitPenalty" filledInOptionals.preTransitPenalty Encode.float, Argument.optional "preTransitOverageRate" filledInOptionals.preTransitOverageRate Encode.float, Argument.optional "preTransitReluctance" filledInOptionals.preTransitReluctance Encode.float, Argument.optional "maxPreTransitWalkDistance" filledInOptionals.maxPreTransitWalkDistance Encode.float, Argument.optional "useFlex" filledInOptionals.useFlex Encode.bool, Argument.optional "banFirstServiceJourneysFromReuseNo" filledInOptionals.banFirstServiceJourneysFromReuseNo Encode.int, Argument.optional "walkBoardCost" filledInOptionals.walkBoardCost Encode.int, Argument.optional "walkReluctance" filledInOptionals.walkReluctance Encode.float, Argument.optional "waitReluctance" filledInOptionals.waitReluctance Encode.float, Argument.optional "ignoreMinimumBookingPeriod" filledInOptionals.ignoreMinimumBookingPeriod Encode.bool, Argument.optional "transitDistanceReluctance" filledInOptionals.transitDistanceReluctance Encode.float ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "trip" (optionalArgs ++ [ Argument.required "from" requiredArgs.from EnturApi.InputObject.encodeLocation, Argument.required "to" requiredArgs.to EnturApi.InputObject.encodeLocation ]) object_ (identity >> Decode.nullable)


type alias StopPlaceRequiredArguments =
    { id : String }


{-| Get a single stopPlace based on its id)
-}
stopPlace : StopPlaceRequiredArguments -> SelectionSet decodesTo EnturApi.Object.StopPlace -> SelectionSet (Maybe decodesTo) RootQuery
stopPlace requiredArgs object_ =
    Object.selectionForCompositeField "stopPlace" [ Argument.required "id" requiredArgs.id Encode.string ] object_ (identity >> Decode.nullable)


type alias StopPlacesOptionalArguments =
    { ids : OptionalArgument (List (Maybe String)) }


{-| Get all stopPlaces
-}
stopPlaces : (StopPlacesOptionalArguments -> StopPlacesOptionalArguments) -> SelectionSet decodesTo EnturApi.Object.StopPlace -> SelectionSet (List (Maybe decodesTo)) RootQuery
stopPlaces fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { ids = Absent }

        optionalArgs =
            [ Argument.optional "ids" filledInOptionals.ids (Encode.string |> Encode.maybe |> Encode.list) ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "stopPlaces" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias StopPlacesByBboxOptionalArguments =
    { minimumLatitude : OptionalArgument Float
    , minimumLongitude : OptionalArgument Float
    , maximumLatitude : OptionalArgument Float
    , maximumLongitude : OptionalArgument Float
    , authority : OptionalArgument String
    , multiModalMode : OptionalArgument EnturApi.Enum.MultiModalMode.MultiModalMode
    , filterByInUse : OptionalArgument Bool
    }


{-| Get all stop places within the specified bounding box

  - multiModalMode - MultiModalMode for query. To control whether multi modal parent stop places, their mono modal children or both are included in the response. Does not affect mono modal stop places that do not belong to a multi modal stop place.
  - filterByInUse - If true only stop places with at least one visiting line are included.

-}
stopPlacesByBbox : (StopPlacesByBboxOptionalArguments -> StopPlacesByBboxOptionalArguments) -> SelectionSet decodesTo EnturApi.Object.StopPlace -> SelectionSet (List (Maybe decodesTo)) RootQuery
stopPlacesByBbox fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { minimumLatitude = Absent, minimumLongitude = Absent, maximumLatitude = Absent, maximumLongitude = Absent, authority = Absent, multiModalMode = Absent, filterByInUse = Absent }

        optionalArgs =
            [ Argument.optional "minimumLatitude" filledInOptionals.minimumLatitude Encode.float, Argument.optional "minimumLongitude" filledInOptionals.minimumLongitude Encode.float, Argument.optional "maximumLatitude" filledInOptionals.maximumLatitude Encode.float, Argument.optional "maximumLongitude" filledInOptionals.maximumLongitude Encode.float, Argument.optional "authority" filledInOptionals.authority Encode.string, Argument.optional "multiModalMode" filledInOptionals.multiModalMode (Encode.enum EnturApi.Enum.MultiModalMode.toString), Argument.optional "filterByInUse" filledInOptionals.filterByInUse Encode.bool ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "stopPlacesByBbox" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias QuayRequiredArguments =
    { id : String }


{-| Get a single quay based on its id)
-}
quay : QuayRequiredArguments -> SelectionSet decodesTo EnturApi.Object.Quay -> SelectionSet (Maybe decodesTo) RootQuery
quay requiredArgs object_ =
    Object.selectionForCompositeField "quay" [ Argument.required "id" requiredArgs.id Encode.string ] object_ (identity >> Decode.nullable)


type alias QuaysOptionalArguments =
    { ids : OptionalArgument (List (Maybe String))
    , name : OptionalArgument String
    }


{-| Get all quays
-}
quays : (QuaysOptionalArguments -> QuaysOptionalArguments) -> SelectionSet decodesTo EnturApi.Object.Quay -> SelectionSet (List (Maybe decodesTo)) RootQuery
quays fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { ids = Absent, name = Absent }

        optionalArgs =
            [ Argument.optional "ids" filledInOptionals.ids (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "name" filledInOptionals.name Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "quays" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias QuaysByBboxOptionalArguments =
    { minimumLatitude : OptionalArgument Float
    , minimumLongitude : OptionalArgument Float
    , maximumLatitude : OptionalArgument Float
    , maximumLongitude : OptionalArgument Float
    , authority : OptionalArgument String
    , filterByInUse : OptionalArgument Bool
    }


{-| Get all quays within the specified bounding box

  - filterByInUse - If true only quays with at least one visiting line are included.

-}
quaysByBbox : (QuaysByBboxOptionalArguments -> QuaysByBboxOptionalArguments) -> SelectionSet decodesTo EnturApi.Object.Quay -> SelectionSet (List (Maybe decodesTo)) RootQuery
quaysByBbox fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { minimumLatitude = Absent, minimumLongitude = Absent, maximumLatitude = Absent, maximumLongitude = Absent, authority = Absent, filterByInUse = Absent }

        optionalArgs =
            [ Argument.optional "minimumLatitude" filledInOptionals.minimumLatitude Encode.float, Argument.optional "minimumLongitude" filledInOptionals.minimumLongitude Encode.float, Argument.optional "maximumLatitude" filledInOptionals.maximumLatitude Encode.float, Argument.optional "maximumLongitude" filledInOptionals.maximumLongitude Encode.float, Argument.optional "authority" filledInOptionals.authority Encode.string, Argument.optional "filterByInUse" filledInOptionals.filterByInUse Encode.bool ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "quaysByBbox" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias QuaysByRadiusOptionalArguments =
    { authority : OptionalArgument String
    , before : OptionalArgument String
    , after : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


type alias QuaysByRadiusRequiredArguments =
    { latitude : Float
    , longitude : Float
    , radius : Int
    }


{-| Get all quays within the specified radius from a location. The returned type has two fields quay and distance

  - latitude - Latitude of the location
  - longitude - Longitude of the location
  - radius - Radius (in meters) to search for from the specified location
  - before - fetching only nodes before this node (exclusive)
  - after - fetching only nodes after this node (exclusive)
  - first - fetching only the first certain number of nodes
  - last - fetching only the last certain number of nodes

-}
quaysByRadius : (QuaysByRadiusOptionalArguments -> QuaysByRadiusOptionalArguments) -> QuaysByRadiusRequiredArguments -> SelectionSet decodesTo EnturApi.Object.QuayAtDistanceConnection -> SelectionSet (Maybe decodesTo) RootQuery
quaysByRadius fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { authority = Absent, before = Absent, after = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "authority" filledInOptionals.authority Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "quaysByRadius" (optionalArgs ++ [ Argument.required "latitude" requiredArgs.latitude Encode.float, Argument.required "longitude" requiredArgs.longitude Encode.float, Argument.required "radius" requiredArgs.radius Encode.int ]) object_ (identity >> Decode.nullable)


type alias NearestOptionalArguments =
    { maximumDistance : OptionalArgument Int
    , maximumResults : OptionalArgument Int
    , filterByPlaceTypes : OptionalArgument (List (Maybe EnturApi.Enum.FilterPlaceType.FilterPlaceType))
    , filterByModes : OptionalArgument (List (Maybe EnturApi.Enum.Mode.Mode))
    , filterByInUse : OptionalArgument Bool
    , filterByIds : OptionalArgument EnturApi.InputObject.InputFilters
    , multiModalMode : OptionalArgument EnturApi.Enum.MultiModalMode.MultiModalMode
    , before : OptionalArgument String
    , after : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


type alias NearestRequiredArguments =
    { latitude : Float
    , longitude : Float
    }


{-| Get all places (quays, stop places, car parks etc. with coordinates) within the specified radius from a location. The returned type has two fields place and distance. The search is done by walking so the distance is according to the network of walkables.

  - latitude - Latitude of the location
  - longitude - Longitude of the location
  - maximumDistance - Maximum distance (in meters) to search for from the specified location. Default is 2000m.
  - maximumResults - Maximum number of results. Search is stopped when this limit is reached. Default is 20.
  - filterByPlaceTypes - Only include places of given types if set. Default accepts all types
  - filterByModes - Only include places that include this mode. Only checked for places with mode i.e. quays, departures.
  - filterByInUse - Only affects queries for quays and stop places. If true only quays and stop places with at least one visiting line are included.
  - filterByIds - Only include places that match one of the given ids.
  - multiModalMode - MultiModalMode for query. To control whether multi modal parent stop places, their mono modal children or both are included in the response. Does not affect mono modal stop places that do not belong to a multi modal stop place. Only applicable for placeType StopPlace
  - before - fetching only nodes before this node (exclusive)
  - after - fetching only nodes after this node (exclusive)
  - first - fetching only the first certain number of nodes
  - last - fetching only the last certain number of nodes

-}
nearest : (NearestOptionalArguments -> NearestOptionalArguments) -> NearestRequiredArguments -> SelectionSet decodesTo EnturApi.Object.PlaceAtDistanceConnection -> SelectionSet (Maybe decodesTo) RootQuery
nearest fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { maximumDistance = Absent, maximumResults = Absent, filterByPlaceTypes = Absent, filterByModes = Absent, filterByInUse = Absent, filterByIds = Absent, multiModalMode = Absent, before = Absent, after = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "maximumDistance" filledInOptionals.maximumDistance Encode.int, Argument.optional "maximumResults" filledInOptionals.maximumResults Encode.int, Argument.optional "filterByPlaceTypes" filledInOptionals.filterByPlaceTypes (Encode.enum EnturApi.Enum.FilterPlaceType.toString |> Encode.maybe |> Encode.list), Argument.optional "filterByModes" filledInOptionals.filterByModes (Encode.enum EnturApi.Enum.Mode.toString |> Encode.maybe |> Encode.list), Argument.optional "filterByInUse" filledInOptionals.filterByInUse Encode.bool, Argument.optional "filterByIds" filledInOptionals.filterByIds EnturApi.InputObject.encodeInputFilters, Argument.optional "multiModalMode" filledInOptionals.multiModalMode (Encode.enum EnturApi.Enum.MultiModalMode.toString), Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "nearest" (optionalArgs ++ [ Argument.required "latitude" requiredArgs.latitude Encode.float, Argument.required "longitude" requiredArgs.longitude Encode.float ]) object_ (identity >> Decode.nullable)


type alias AuthorityRequiredArguments =
    { id : String }


{-| Get an authority by ID
-}
authority : AuthorityRequiredArguments -> SelectionSet decodesTo EnturApi.Object.Authority -> SelectionSet (Maybe decodesTo) RootQuery
authority requiredArgs object_ =
    Object.selectionForCompositeField "authority" [ Argument.required "id" requiredArgs.id Encode.string ] object_ (identity >> Decode.nullable)


{-| Get all authorities
-}
authorities : SelectionSet decodesTo EnturApi.Object.Authority -> SelectionSet (List (Maybe decodesTo)) RootQuery
authorities object_ =
    Object.selectionForCompositeField "authorities" [] object_ (identity >> Decode.nullable >> Decode.list)


type alias OperatorRequiredArguments =
    { id : String }


{-| Get a operator by ID
-}
operator : OperatorRequiredArguments -> SelectionSet decodesTo EnturApi.Object.Operator -> SelectionSet (Maybe decodesTo) RootQuery
operator requiredArgs object_ =
    Object.selectionForCompositeField "operator" [ Argument.required "id" requiredArgs.id Encode.string ] object_ (identity >> Decode.nullable)


{-| Get all operators
-}
operators : SelectionSet decodesTo EnturApi.Object.Operator -> SelectionSet (List (Maybe decodesTo)) RootQuery
operators object_ =
    Object.selectionForCompositeField "operators" [] object_ (identity >> Decode.nullable >> Decode.list)


type alias OrganisationRequiredArguments =
    { id : String }


organisation : OrganisationRequiredArguments -> SelectionSet decodesTo EnturApi.Object.Organisation -> SelectionSet (Maybe decodesTo) RootQuery
organisation requiredArgs object_ =
    Object.selectionForCompositeField "organisation" [ Argument.required "id" requiredArgs.id Encode.string ] object_ (identity >> Decode.nullable)


organisations : SelectionSet decodesTo EnturApi.Object.Organisation -> SelectionSet (List (Maybe decodesTo)) RootQuery
organisations object_ =
    Object.selectionForCompositeField "organisations" [] object_ (identity >> Decode.nullable >> Decode.list)


type alias LineRequiredArguments =
    { id : String }


{-| Get a single line based on its id
-}
line : LineRequiredArguments -> SelectionSet decodesTo EnturApi.Object.Line -> SelectionSet (Maybe decodesTo) RootQuery
line requiredArgs object_ =
    Object.selectionForCompositeField "line" [ Argument.required "id" requiredArgs.id Encode.string ] object_ (identity >> Decode.nullable)


type alias LinesOptionalArguments =
    { ids : OptionalArgument (List (Maybe String))
    , name : OptionalArgument String
    , publicCode : OptionalArgument String
    , publicCodes : OptionalArgument (List (Maybe String))
    , transportModes : OptionalArgument (List (Maybe EnturApi.Enum.TransportMode.TransportMode))
    , authorities : OptionalArgument (List (Maybe String))
    , flexibleLineTypes : OptionalArgument (List (Maybe EnturApi.Enum.FlexibleLineType.FlexibleLineType))
    }


{-| Get all lines

  - authorities - Set of ids of authorities to fetch lines for.

-}
lines : (LinesOptionalArguments -> LinesOptionalArguments) -> SelectionSet decodesTo EnturApi.Object.Line -> SelectionSet (List (Maybe decodesTo)) RootQuery
lines fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { ids = Absent, name = Absent, publicCode = Absent, publicCodes = Absent, transportModes = Absent, authorities = Absent, flexibleLineTypes = Absent }

        optionalArgs =
            [ Argument.optional "ids" filledInOptionals.ids (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "name" filledInOptionals.name Encode.string, Argument.optional "publicCode" filledInOptionals.publicCode Encode.string, Argument.optional "publicCodes" filledInOptionals.publicCodes (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "transportModes" filledInOptionals.transportModes (Encode.enum EnturApi.Enum.TransportMode.toString |> Encode.maybe |> Encode.list), Argument.optional "authorities" filledInOptionals.authorities (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "flexibleLineTypes" filledInOptionals.flexibleLineTypes (Encode.enum EnturApi.Enum.FlexibleLineType.toString |> Encode.maybe |> Encode.list) ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "lines" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias ServiceJourneyRequiredArguments =
    { id : String }


{-| Get a single service journey based on its id
-}
serviceJourney : ServiceJourneyRequiredArguments -> SelectionSet decodesTo EnturApi.Object.ServiceJourney -> SelectionSet (Maybe decodesTo) RootQuery
serviceJourney requiredArgs object_ =
    Object.selectionForCompositeField "serviceJourney" [ Argument.required "id" requiredArgs.id Encode.string ] object_ (identity >> Decode.nullable)


type alias ServiceJourneysOptionalArguments =
    { lines : OptionalArgument (List (Maybe String))
    , privateCodes : OptionalArgument (List (Maybe String))
    , activeDates : OptionalArgument (List (Maybe EnturApi.ScalarCodecs.Date))
    , authorities : OptionalArgument (List (Maybe String))
    }


{-| Get all service journeys

  - lines - Set of ids of lines to fetch serviceJourneys for.
  - privateCodes - Set of ids of private codes to fetch serviceJourneys for.
  - activeDates - Set of ids of active dates to fetch serviceJourneys for.
  - authorities - Set of ids of authorities to fetch serviceJourneys for.

-}
serviceJourneys : (ServiceJourneysOptionalArguments -> ServiceJourneysOptionalArguments) -> SelectionSet decodesTo EnturApi.Object.ServiceJourney -> SelectionSet (List (Maybe decodesTo)) RootQuery
serviceJourneys fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { lines = Absent, privateCodes = Absent, activeDates = Absent, authorities = Absent }

        optionalArgs =
            [ Argument.optional "lines" filledInOptionals.lines (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "privateCodes" filledInOptionals.privateCodes (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "activeDates" filledInOptionals.activeDates ((EnturApi.ScalarCodecs.codecs |> EnturApi.Scalar.unwrapEncoder .codecDate) |> Encode.maybe |> Encode.list), Argument.optional "authorities" filledInOptionals.authorities (Encode.string |> Encode.maybe |> Encode.list) ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "serviceJourneys" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias BikeRentalStationsOptionalArguments =
    { ids : OptionalArgument (List (Maybe String)) }


{-| Get all bike rental stations
-}
bikeRentalStations : (BikeRentalStationsOptionalArguments -> BikeRentalStationsOptionalArguments) -> SelectionSet decodesTo EnturApi.Object.BikeRentalStation -> SelectionSet (List (Maybe decodesTo)) RootQuery
bikeRentalStations fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { ids = Absent }

        optionalArgs =
            [ Argument.optional "ids" filledInOptionals.ids (Encode.string |> Encode.maybe |> Encode.list) ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "bikeRentalStations" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias BikeRentalStationRequiredArguments =
    { id : String }


{-| Get a single bike rental station based on its id
-}
bikeRentalStation : BikeRentalStationRequiredArguments -> SelectionSet decodesTo EnturApi.Object.BikeRentalStation -> SelectionSet (Maybe decodesTo) RootQuery
bikeRentalStation requiredArgs object_ =
    Object.selectionForCompositeField "bikeRentalStation" [ Argument.required "id" requiredArgs.id Encode.string ] object_ (identity >> Decode.nullable)


type alias BikeRentalStationsByBboxOptionalArguments =
    { minimumLatitude : OptionalArgument Float
    , minimumLongitude : OptionalArgument Float
    , maximumLatitude : OptionalArgument Float
    , maximumLongitude : OptionalArgument Float
    }


{-| Get all bike rental stations within the specified bounding box.
-}
bikeRentalStationsByBbox : (BikeRentalStationsByBboxOptionalArguments -> BikeRentalStationsByBboxOptionalArguments) -> SelectionSet decodesTo EnturApi.Object.BikeRentalStation -> SelectionSet (List (Maybe decodesTo)) RootQuery
bikeRentalStationsByBbox fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { minimumLatitude = Absent, minimumLongitude = Absent, maximumLatitude = Absent, maximumLongitude = Absent }

        optionalArgs =
            [ Argument.optional "minimumLatitude" filledInOptionals.minimumLatitude Encode.float, Argument.optional "minimumLongitude" filledInOptionals.minimumLongitude Encode.float, Argument.optional "maximumLatitude" filledInOptionals.maximumLatitude Encode.float, Argument.optional "maximumLongitude" filledInOptionals.maximumLongitude Encode.float ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "bikeRentalStationsByBbox" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias BikeParkRequiredArguments =
    { id : String }


{-| Get a single bike park based on its id
-}
bikePark : BikeParkRequiredArguments -> SelectionSet decodesTo EnturApi.Object.BikePark -> SelectionSet (Maybe decodesTo) RootQuery
bikePark requiredArgs object_ =
    Object.selectionForCompositeField "bikePark" [ Argument.required "id" requiredArgs.id Encode.string ] object_ (identity >> Decode.nullable)


{-| Get all bike parks
-}
bikeParks : SelectionSet decodesTo EnturApi.Object.BikePark -> SelectionSet (List (Maybe decodesTo)) RootQuery
bikeParks object_ =
    Object.selectionForCompositeField "bikeParks" [] object_ (identity >> Decode.nullable >> Decode.list)


type alias CarParkRequiredArguments =
    { id : String }


{-| Get a single car park based on its id
-}
carPark : CarParkRequiredArguments -> SelectionSet decodesTo EnturApi.Object.CarPark -> SelectionSet (Maybe decodesTo) RootQuery
carPark requiredArgs object_ =
    Object.selectionForCompositeField "carPark" [ Argument.required "id" requiredArgs.id Encode.string ] object_ (identity >> Decode.nullable)


type alias CarParksOptionalArguments =
    { ids : OptionalArgument (List (Maybe String)) }


{-| Get all car parks
-}
carParks : (CarParksOptionalArguments -> CarParksOptionalArguments) -> SelectionSet decodesTo EnturApi.Object.CarPark -> SelectionSet (List (Maybe decodesTo)) RootQuery
carParks fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { ids = Absent }

        optionalArgs =
            [ Argument.optional "ids" filledInOptionals.ids (Encode.string |> Encode.maybe |> Encode.list) ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "carParks" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


{-| Get default routing parameters.
-}
routingParameters : SelectionSet decodesTo EnturApi.Object.RoutingParameters -> SelectionSet (Maybe decodesTo) RootQuery
routingParameters object_ =
    Object.selectionForCompositeField "routingParameters" [] object_ (identity >> Decode.nullable)


{-| Get all notices
-}
notices : SelectionSet decodesTo EnturApi.Object.Notice -> SelectionSet (List (Maybe decodesTo)) RootQuery
notices object_ =
    Object.selectionForCompositeField "notices" [] object_ (identity >> Decode.nullable >> Decode.list)


type alias SituationsOptionalArguments =
    { authorities : OptionalArgument (List (Maybe String))
    , severities : OptionalArgument (List (Maybe EnturApi.Enum.Severity.Severity))
    }


{-| Get all active situations

  - authorities - Filter by reporting authorities.
  - severities - Filter by severity.

-}
situations : (SituationsOptionalArguments -> SituationsOptionalArguments) -> SelectionSet decodesTo EnturApi.Object.PtSituationElement -> SelectionSet (List (Maybe decodesTo)) RootQuery
situations fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { authorities = Absent, severities = Absent }

        optionalArgs =
            [ Argument.optional "authorities" filledInOptionals.authorities (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "severities" filledInOptionals.severities (Encode.enum EnturApi.Enum.Severity.toString |> Encode.maybe |> Encode.list) ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "situations" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)
